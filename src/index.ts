/*eslint-disable no-console */
import chalk from "chalk";
import { promises as fs } from "fs";
import { mkdir } from "fs/promises";
import { glob } from "glob";
import { parse } from "node-html-parser";
import path from "path";
import type { Plugin } from "vite";
import { normalizePath } from "vite";

interface PluginProps {
  withTypes?: boolean;
  inputDir: string;
  outputDir: string;
  fileName?: string;
  typeFileName?: string;
  grouped?: boolean;
  cwd?: string;
}

const generateIcons = async ({ withTypes = false, inputDir, outputDir, grouped, cwd, fileName = "sprite.svg", typeFileName = "types.ts" }: PluginProps) => {
  const cwdToUse = cwd ?? process.cwd();
  const inputDirRelative = path.relative(cwdToUse, inputDir);
  const outputDirRelative = path.relative(cwdToUse, outputDir);

  const files = glob.sync("**/*.svg", {
    cwd: inputDir,
  });

  if (files.length === 0) {
    console.log(`‚ö†Ô∏è  No SVG files found in ${chalk.red(inputDirRelative)}`);
    return;
  }

  await mkdir(outputDirRelative, { recursive: true });

  if (grouped) {
    // Group SVGs by directory
    const groupedFiles: { [key: string]: string[]; } = {};
    files.forEach((file) => {
      const directory = path.dirname(file);
      if (!groupedFiles[directory]) {
        groupedFiles[directory] = [];
      }
      groupedFiles[directory].push(file);
    });

    // Generate SVG sprite for each group
    for (const groupDir in groupedFiles) {
      const groupFileName = fileName.replace('.svg', `_${groupDir}.svg`);
      await generateSvgSprite({
        files: groupedFiles[groupDir],
        inputDir,
        outputPath: path.join(outputDir, groupFileName),
        outputDirRelative,
      });
    }
  } else {
    // Generate a single SVG sprite without grouping
    await generateSvgSprite({
      files,
      inputDir,
      outputPath: path.join(outputDir, fileName),
      outputDirRelative,
    });
  }

  if (!withTypes)
    return;


  await generateTypes({
    names: files.map((file: string) => fileNameToCamelCase(file.replace(/\.svg$/, ""))),
    outputPath: path.join(outputDir, typeFileName),
  });

};

function fileNameToCamelCase(fileName: string): string {
  const words = fileName.split("-");
  const capitalizedWords = words.map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  return capitalizedWords.join("");
}

/**
 * Creates a single SVG file that contains all the icons
 */
async function generateSvgSprite({
  files,
  inputDir,
  outputPath,
  outputDirRelative,
}: {
  files: string[];
  inputDir: string;
  outputPath: string;
  outputDirRelative?: string;
}) {
  try {
    // Each SVG becomes a symbol and we wrap them all in a single SVG
    const symbols = await Promise.all(
      files.map(async (file) => {
        try {
          const fileName = fileNameToCamelCase(file.replace(/\.svg$/, ""));
          const input = await fs.readFile(path.join(inputDir, file), "utf8");

          const root = parse(input);
          const svg = root.querySelector("svg");
          if (!svg) {
            console.log(`‚ö†Ô∏è No SVG tag found in ${file}`);
            return;
          }
          svg.tagName = "symbol";
          svg.setAttribute("id", fileName);
          svg.removeAttribute("xmlns");
          svg.removeAttribute("xmlns:xlink");
          svg.removeAttribute("version");
          svg.removeAttribute("width");
          svg.removeAttribute("height");
          return svg.toString().trim();
        } catch (error) {
          console.error(`‚ùå Error processing ${file}: ${error}`);
          return;
        }
      })
    );

    const output = [
      '<?xml version="1.0" encoding="UTF-8"?>',
      '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">',
      "<defs>",
      ...symbols.filter(Boolean),
      "</defs>",
      "</svg>",
    ].join("\n");

    await writeIfChanged(outputPath, output, `üñºÔ∏è  Generated SVG spritesheet in ${chalk.green(outputDirRelative)}`);
  } catch (error) {
    console.error(`‚ùå Error generating SVG spritesheet: ${error}`);
  }
}

async function generateTypes({ names, outputPath }: { names: string[]; outputPath: string; }) {
  const output = [
    "// This file is generated by spriteify",
    "",
    "export type IconName =",
    ...names.map((name) => `  | "${name}"`),
    "",
    "export const iconNames = [",
    ...names.map((name) => `  "${name}",`),
    "] as const",
    "",
  ].join("\n");

  const file = await writeIfChanged(
    outputPath,
    output,
    `${chalk.blueBright("TS")} Generated icon types in ${chalk.green(outputPath)}`
  );
  return file;
}

async function writeIfChanged(filepath: string, newContent: string, message: string) {
  try {
    await fs.access(filepath);
    const currentContent = await fs.readFile(filepath, "utf8");
    if (currentContent !== newContent) {
      await fs.writeFile(filepath, newContent, "utf8");
      console.log(message);
    }
  } catch (error: any) {
    if (error?.code && error?.code === "ENOENT") {
      await fs.writeFile(filepath, newContent, "utf8");
      console.log(message);
    } else {
      console.error(`‚ùå Error accessing file ${filepath}: ${error}`);
    }
  }
}

export function spriteify({ withTypes, inputDir, outputDir, fileName, typeFileName, grouped, cwd }: PluginProps): Plugin {
  return ({
    name: "spriteify",
    apply(config) {
      return config.mode === "development";
    },
    async watchChange(file, type) {
      const inputPath = normalizePath(path.join(cwd ?? process.cwd(), inputDir));
      if (file.includes(inputPath) && file.endsWith(".svg") && ["create", "delete"].includes(type.event)) {
        await generateIcons({
          withTypes,
          inputDir,
          outputDir,
          fileName,
          typeFileName,
          grouped,
          cwd
        });
      }
    },
    async handleHotUpdate({ file }) {
      const inputPath = normalizePath(path.join(cwd ?? process.cwd(), inputDir));
      if (file.includes(inputPath) && file.endsWith(".svg")) {
        await generateIcons({
          withTypes,
          inputDir,
          outputDir,
          fileName,
          typeFileName,
          grouped,
          cwd
        });
      }
    },
  });
}
