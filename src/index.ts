/* eslint-disable no-console */
import chalk from 'chalk';
import { access, mkdir, readFile, writeFile } from 'fs/promises';
import { glob } from 'glob';
import { parse } from 'node-html-parser';
import path from 'path';
import type { Plugin } from 'vite';
import { normalizePath } from 'vite';

interface PluginProps {
  inputDir: string;
  outputDir: string;
  withTypes?: boolean;
  fileName?: string;
  typeFileName?: string;
  grouped?: boolean;
  cwd?: string;
}

const generateIcons = async ({
  inputDir,
  outputDir,
  grouped,
  cwd,
  withTypes = false,
  fileName = 'sprite.svg',
  typeFileName = 'types.ts',
}: PluginProps) => {
  const cwdToUse = cwd ?? process.cwd();
  const inputDirRelative = path.relative(cwdToUse, inputDir);
  const outputDirRelative = path.relative(cwdToUse, outputDir);

  const files = glob.sync('**/*.svg', {
    cwd: inputDir,
  });

  if (files.length === 0) {
    console.log(`‚ö†Ô∏è  No SVG files found in ${chalk.red(inputDirRelative)}`);
    return;
  }

  await mkdir(outputDirRelative, { recursive: true });

  if (grouped) {
    const groupedFiles: Record<string, string[]> = {};
    files.forEach((file) => {
      const directory = path.dirname(file);
      if (!groupedFiles[directory]) {
        groupedFiles[directory] = [];
      }
      groupedFiles[directory].push(file);
    });

    for (const groupDir in groupedFiles) {
      const groupFileName = fileName.replace('.svg', `_${groupDir}.svg`);
      await generateSvgSprite({
        files: groupedFiles[groupDir],
        inputDir,
        outputPath: path.join(outputDir, groupFileName),
        outputDirRelative,
      });
    }
  } else {
    await generateSvgSprite({
      files,
      inputDir,
      outputPath: path.join(outputDir, fileName),
      outputDirRelative,
    });
  }

  if (!withTypes) return;

  await generateTypes({
    names: files.map((file) => fileNameToCamelCase(file.replace(/\.svg$/, ''))),
    outputPath: path.join(outputDir, typeFileName),
  });
};

const fileNameToCamelCase = (fileName: string): string => {
  return fileName
    .split('-')
    .map((word, index) => {
      if (index === 0) {
        return word;
      }
      return word.charAt(0).toUpperCase() + word.slice(1);
    })
    .join('');
};

const generateSvgSprite = async ({
  files,
  inputDir,
  outputPath,
  outputDirRelative,
}: {
  files: string[];
  inputDir: string;
  outputPath: string;
  outputDirRelative?: string;
}) => {
  try {
    const symbols = await Promise.all(
      files.map(async (file) => {
        try {
          const fileName = fileNameToCamelCase(file.replace(/\.svg$/, ''));
          const input = await readFile(path.join(inputDir, file), 'utf8');

          const root = parse(input);
          const svg = root.querySelector('svg');
          if (!svg) {
            console.log(`‚ö†Ô∏è No SVG tag found in ${file}`);
            return '';
          }
          svg.tagName = 'symbol';
          svg.setAttribute('id', fileName);
          ['xmlns', 'xmlns:xlink', 'version', 'width', 'height'].forEach((attr) =>
            svg.removeAttribute(attr)
          );
          return svg.toString().trim();
        } catch (error) {
          console.error(`‚ùå Error processing ${file}: ${error}`);
          return '';
        }
      })
    );

    const output = [
      '<?xml version="1.0" encoding="UTF-8"?>',
      '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">',
      '<defs>',
      ...symbols.filter(Boolean),
      '</defs>',
      '</svg>',
    ].join('\n');

    await writeIfChanged(outputPath, output, `üñºÔ∏è  Generated SVG spritesheet in ${chalk.green(outputDirRelative)}`);
  } catch (error) {
    console.error(`‚ùå Error generating SVG spritesheet: ${error}`);
  }
};

const generateTypes = async ({ names, outputPath }: { names: string[]; outputPath: string; }) => {
  const output = [
    '// This file is generated by spriteify',
    '',
    'export type IconName =',
    ...names.map((name) => `  | "${name}"`),
    '',
    'export const iconNames = [',
    ...names.map((name) => `  "${name}",`),
    '] as const',
    '',
  ].join('\n');

  await writeIfChanged(outputPath, output, `${chalk.blueBright('TS')} Generated icon types in ${chalk.green(outputPath)}`);
};

const writeIfChanged = async (filepath: string, newContent: string, message: string) => {
  try {
    await access(filepath);
    const currentContent = await readFile(filepath, 'utf8');
    if (currentContent !== newContent) {
      await writeFile(filepath, newContent, 'utf8');
      console.log(message);
    }
  } catch (error: any) {
    if (error?.code === 'ENOENT') {
      await writeFile(filepath, newContent, 'utf8');
      console.log(message);
    } else {
      console.error(`‚ùå Error accessing file ${filepath}: ${error}`);
    }
  }
};

export function spriteify({
  withTypes,
  inputDir,
  outputDir,
  fileName,
  typeFileName,
  grouped,
  cwd,
}: PluginProps): Plugin {
  return {
    name: 'spriteify',
    apply(config) {
      return config.mode === 'development';
    },
    async watchChange(file, type) {
      const inputPath = normalizePath(path.join(cwd ?? process.cwd(), inputDir));
      if (file.includes(inputPath) && file.endsWith('.svg') && ['create', 'delete'].includes(type.event)) {
        await generateIcons({
          withTypes,
          inputDir,
          outputDir,
          fileName,
          typeFileName,
          grouped,
          cwd,
        });
      }
    },
    async handleHotUpdate({ file }) {
      const inputPath = normalizePath(path.join(cwd ?? process.cwd(), inputDir));
      if (file.includes(inputPath) && file.endsWith('.svg')) {
        await generateIcons({
          withTypes,
          inputDir,
          outputDir,
          fileName,
          typeFileName,
          grouped,
          cwd,
        });
      }
    },
  };
}
